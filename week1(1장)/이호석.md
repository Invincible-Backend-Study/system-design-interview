# 📌 1장 사용자 수에 따른 규모 확장성

## 1. 단일 서버 (DB 포함)

![image](https://github.com/user-attachments/assets/e6f4ca4a-466b-45f0-b2bc-aec1d178e0c3)


- 고려사항
    - 어떤 DB를 사용할 것인가? (RDB, NoSQL)
    - RDB 적합한 상황(대부분이지 않을까 예상됨)
        - 데이터 간의 관계가 중요한 경우
        - 데이터가 정형 데이터 일 때
    - NoSQL이 적합한 상황
        - 아주 낮은 응답 지연시간이 요구될때
        - 다루는 데이터가 비정형 데이터
        - 데이터의 직렬화 및 역직렬화만 필요한 경우
        - 아주 많은 양의 데이터를 저장해야 할 때

<br><br>

## 2. Scale-up, Scale-out

- `Scale-up`
    - 서버 자체의 사양을 올리는 행위
    - 서버로 유입되는 트래픽의 양이 적을때 추천함
    - 단순함이 가장 큰 장점
    - 단점
        - 자원은 무한대로 늘릴 수 없음
        - 자동복구(failover), 다중화(re-dundancy) 방안 X
- `Scale-out`
    - Scale-up의 단점 때문에 추천함

![image](https://github.com/user-attachments/assets/542cbb7e-27a0-4099-800d-373228556bb2)


- Scale-out을 적용하고 일반적으로 로드밸런서와 같이 물려서 사용함
- 하나의 서버가 다운돼도 다른 서버로 요청을 전송하면 되므로 자동복구(failover)를 지원함
- 서버의 트래픽이 폭주해도, 서버를 더 늘려주면 됨

> 서버만 늘린다고 능사가 아님, DB또한 장애복구, 다중화의 지원을 위한 장치가 있음
> 

![image](https://github.com/user-attachments/assets/8178be25-cf62-4043-9919-372c77b53922)


- `주 데이터베이스 서버(source, master 등)`
    - 쓰기 요청에 대한 처리를 함 (insert, update, delete)
- `부 데이터베이스 서버(replica, slave 등)`
    - 주 데이터베이스 서버에서 변경된 데이터 이력을 자신의 DB에 적용하고 읽기 요청에 대한 처리를 함

- 왜 이렇게 나눌까?
    - 일반적으로 쓰기 연산보다 읽기 연산이 훨씬 비중이 크기 때문에 위와 같이 구성함
- 장점은?
    - DB 요청이 분산되어 성능 향상
    - DB서버 하나가 죽어도 다중화 해놓은 덕분에 복구할 수 있음 → 고가용성 제공
- `궁금한 부분들`
    - DB를 레플리케이션 했을때 Source서버에 변경된 데이터가 Replica서버에 적용되기 까지 텀이 존재하는데 이때 변경된 데이터에 대해 읽기 요청이 왔을때는 최신의 데이터를 보여주기 위해 어떻게 처리해야 할까?
    - 더 나아가서 변경된 데이터에 대해 그 즉시 읽기 요청이 상당히 많이 들어오는 서비스라면 결국 Source서버에 질의가 몰리게 되는데 이때 지연이 발생하거나 타임아웃이 발생하는경우가 있을 수 있잖아? 이럴때는 어떻게 문제를 해결할 수 있을까?

<br><br>

## 3. 캐시

값비싼 연산 결과 혹은 자주 차조되는 데이터를 미리 메모리에 올려놓고 빠른 응답을 주기위해 사용되는 저장소

- 캐시 읽기 전략
    - `Cache-Aside(Look-Aside)`
        - 캐시 있으면 반환 없으면 DB조회해 클라이언트에게 반환하고 캐시 업데이트
        - 범용적으로 사용되며 읽기 많을때 적합
        - DB데이터와 일치하지 않을 수 있음 → 적절한 TTL값이 필요
        - Cache에 저장하는 주체가 서버임
    - `Read-Through`
        - 캐시 있으면 반환, 없으면 DB에서 누락된 데이터를 캐시에 채우고 애플리케이션에 반환
        - Cache-Aside와 마찬가지로 데이터를 처음 읽을때만 로드함
        - Cache에 저장하는 주체가 서버가 아니라 자기 자신임
        - 장: 실제 DB데이터와 일치하지 않을 수 있음
        - 단: 일반적으로 동일한 데이터를 자주 조회하는 경우 추천함
- 캐시 쓰기 전략
    - `Write-Through`
        - 데이터가 먼저 캐시에 기록된 후 DB에 기록함
        - 캐시가 DB에 직접 쓰기 작업을 함
        - 장: 데이터의 정합성이 보장됨 (특히 `read-through`와 같이 사용했을때)
        - 단: 항상 두 번의 쓰기 작업이 진행되고, 자주 사용되지 않은 불필요한 리소스도 캐시에 저장됨
    - `Write-Around`
        - 데이터는 DB에 직접 기록되고 읽은 데이터만 캐시에 기록합니다.
        - read-through, cache-aside와 모두 결합하여 사용할 수 있음
        - 장: 데이터가 한 번 기록되고 자주 읽지 않거나, 전혀 읽지 않는 상황에서 좋은 성능을 보임(실시간 로그, 채팅방)
        - 단: 캐시와 DB 데이터가 다를 수 있음
    - `Write-Back(Write-Behind)`
        - 애플리케이션은 변경 데이터를 캐시에 모아서 일정 주기마다 DB에 반영하는 배치작업을 돌림
        - 주로 쓰기가 빈번한 상황에서 유용함
        - 장: DB에 쓰기 연산횟수를 줄일 수 있음
        - 장: 데이터 정합성을 확보할 수 있음
        - 단: 장애 발생 시 데이터가 영구 손실될 수 있음

- 유의점
    - 어떤 상황에 바람직한지?
        - 적은 데이터 갱신, 잦은 참조
    - 어떤 데이터를 캐싱할지?
        - 민감 정보는 추천하지 않음
    - 만료 기간?
        - 너무 짧으면 캐싱의 의미가 적어지고, 너무 길면 원본 데이터와 차이가 날 가능성 높아짐
    - 일관성 유지?
        - 전략 설정
    - 장애 대처?
        - SPOF가 될 수 있음 → 캐시 분산 필요
    - 메모리 크기는?
    - 데이터 eviction(방출) 정책은?
        - 캐시가 꽉 찼을때 → LRU, LFU, FIFO등 다양한 전략 설정 가능

<br><br>

## 4. CDN(Content Delivery Network) 콘텐츠 전송 네트워크

정적 콘텐츠를 캐싱할때 사용됨 → 지리적으로 가까운 곳에 CDN서버를 두어 빠른 응답을 줄 수 있게 함

![image](https://github.com/user-attachments/assets/6d58ff7d-9b9f-4bf3-996d-712c4dd1b68f)


`비용`, `적절한 만료 시한`, `장애시 대처 방안`, `콘텐츠 무효화 방법`에 대해 고려해야 함

- 캐시 + CDN 적용
    
    ![image](https://github.com/user-attachments/assets/378c12f8-10ed-4709-bf67-df164b838b6b)


<br><br>

## 5. 무상태(stateless) 웹 계층

웹 계층을 Scale-out하기 위해선 서버에 종속된 상태 정보를 제거해야 합니다. (무상태 웹계층)
특히 세션과 같은 경우 무상태 웹 계층과 반대되는 상황에선 이를 고려해야 합니다.

- 토큰 기반 인증, 공유 저장소, sticky session, 클라이언트 사이드 스토리지 등이 존재

![image](https://github.com/user-attachments/assets/8e314125-5ff9-4770-9466-ba1ff9f09fc5)


- 책에서는 공유 저장소를 활용해 해결함

<br><br>

## 6. 데이터 센터

![image](https://github.com/user-attachments/assets/0fade838-eae0-45af-a824-196da9317dc8)


여러 데이터 센터를 두어 사용자에게 더 가까운 데이터 센터로 안내될 수 있도록 함 (지리적 라우팅)
만약 하나의 데이터 센터가 장애가 발생하면 해당 트래픽을 다른 데이터 센터로 우회할 수 있음

다만 이를 구현하기 위해 `트래픽 우회`, `데이터 동기화`, `테스트 및 배포`에 대한 기술적 난제들이 존재합니다.

<br><br>

## 7. 메시지 큐

메시지 큐는 큐에 보관된 데이터는 소비자가 꺼낼때까지 안전히 보관된다는 특정을 보장하는 비동기 통신 지원 컴포넌트 입니다.

서비스나 서버 간 결합을 느슨하게 유지할 수 있고, 소비자와 생산자는 서로 가용 상태가 아니어도 메시지를 수신하거나 발행할 수 있습니다. (MQ가 살아있다면)

<br><br>

## 8. 로그, 메트릭 그리고 자동화

![image](https://github.com/user-attachments/assets/7fa250e0-c194-46d7-9ee7-f4172244c92d)


- `로그`
    - 에러 로그 모니터링은 서비스가 커질수록 중요함, 서버 단위로 모니터링할 수 있고, 로그를 한곳에 모아서 볼 수 있는 도구도 존재(ELK 등)
- `메트릭`
    - 호스트 단위 메트릭 (CPU, 메모리, 디스크 l/O), 종합 메트릭(DB 계층 성능, 캐시 계층 성능), 핵심 비즈니스 메트릭(DAU, 수익, 재방문율 등)
- `자동화`
    - CI/CD와 같은 도구는 시스템이 크고 복잡해졌을때 자동으로 검증 절차를 진행하고 배포까지 해주므로 생산성을 향상시킴

<br><br>

## 9. DB의 규모 확장

![image](https://github.com/user-attachments/assets/148720f4-0fdb-42c6-941e-1a1dcdb68206)


- 수직적 확장
    - 항상 한계가 존재(SPOF, 하드웨어 한계, 비용 문제)
- 수평적 확장
    - 샤딩이 있음
        - 가장 중요하게 고려할것은 샤딩 키를 어떻게 설정할 것이냐 → 데이터를 고르게 분할 할 수 있도록 하는 키를 선정하는 것이 중요함

- 샤딩에서 발생할 수 있는 문제
    - `데이터의 재샤딩` → 기존 샤드들로 감당하기 어려울때, 한 공간이 다른 샤딩 공간보다 빠르게 소진될때
    - `유명인사 문제` → 특정 샤드에 집중될때
    - `조인과 비정규화` → 여러 샤드에 걸쳐 데이터를 조인하기 힘듦 → 데이터를 반정규화하여 하나의 테이블에 질의가 수행하도록 하는것도 방법임

- `샤딩 and 파티셔닝`
    - 샤딩은 수평 파티셔닝과 비슷하지만, 파티셔닝은 동일한 컴퓨터에 저장하고 샤딩은 서로 다른 컴퓨터에 분산 저장합니다.

<br><br>

## 10. 결국

**시스템의 규모 확장은 지속적이고 반복적인 과정임**

![image](https://github.com/user-attachments/assets/74dba797-9501-4c74-bbe6-af5c4680c96c)
